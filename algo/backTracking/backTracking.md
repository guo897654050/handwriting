## 回溯总结

1. 全排列的问题
   - 求全排列，给的nums不重复，一般使用used数组，因为这里位置不同，算作不同的数组。
   - 求全排列，但是给的nums重复，这时候要进行剪枝，剪枝的方法判断` i > 0 && nums[i] === nums[i-1] && used[i-1] === false`，还要判断回溯前的`used[i-1] === false`，由于判断`nums[i] === nums[i-1]`，需要预先对数组进行排序。

2. 求子集
  - 给的nums不重复，一般设定一个begin下标，终止的条件是自动跳出for循环。通过`dfs(i+1)`来进行跳过当前下标。
  - 给的nums重复，那么需要对数组进行排序。增加`i > begin && nums[i] === nums[i-1]`判断。