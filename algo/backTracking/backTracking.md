## 回溯总结

1. 全排列的问题
   - 求全排列，给的nums不重复，一般使用used数组，因为这里位置不同，算作不同的数组。
   - 求全排列，但是给的nums重复，这时候要进行剪枝，剪枝的方法判断` i > 0 && nums[i] === nums[i-1] && used[i-1] === false`，还要判断回溯前的`used[i-1] === false`，由于判断`nums[i] === nums[i-1]`，需要预先对数组进行排序。

2. 求子集
  - 给的nums不重复，一般设定一个begin下标，终止的条件是自动跳出for循环。通过`dfs(i+1)`来进行跳过当前下标。
  - 给的nums重复，那么需要对数组进行排序。增加`i > begin && nums[i] === nums[i-1]`判断。

3. 对于需要去重的，我们都会使用`begin`变量，但是需要注意的是，如果本元素可以重复使用，那么下次递归可以使用该元素`dfs(i)`,39题目。而对于不可使用的，则需要越过当前元素`dfs(i+1)`，如子集回溯。